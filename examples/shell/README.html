<h1>First things to do in <a href="https://www.ubuntu.com/">Ubuntu</a></h1>
<p>This is an example from my course on systems 
programming (<a href="https://down.dsg.cs.tcd.ie/cs2014">CS2014</a>),
the canonical URL for this is 
<a href="https://down.dsg.cs.tcd.ie/cs2014/examples/shell/README.html">here</a>.</p>
<p>If you're installing Ubuntu on a machine at home (a good thing to do) then
you'll be after things like <a href="https://askubuntu.com/questions/307802/how-to-install-ubuntu-on-a-usb-stick">HOWTO make an install USB
stick</a>,
and <a href="http://www.omgubuntu.co.uk/2016/04/10-things-to-do-after-installing-ubuntu-16-04-lts">things to do after installing
Ubuntu</a>.
Those are fine things but here we'll assume you've installed Ubuntu 16.04 or
better, i.e. we assume the machines in LG12.</p>
<h2>Files in this example:</h2>
<ul>
<li>README.md - this file in markdown format</li>
<li>README.html - this file, in HTML format (<code>'make html'</code> to update that from .md)</li>
<li>Makefile - to build the example and HTML (there's a clean target too)</li>
</ul>
<p>After running <code>'make'</code> then this file will be produced (if all
goes well):</p>
<h2>Log in to the system</h2>
<p>You should have your username and password, let's say those are
<code>student100</code> and whatever you've been given for a password.
Logging in to the GUI is pretty obvious (I hope:-).</p>
<p>Once logged in, you want to get a command line/shell. There are
GUI based ways to fire up a shell, but <code>ctrl-alt-t</code> also
works and is useful in case there's no obvious icon for a command
line/shell. (There are loads of online guides to getting 
started with the shell, <a href="http://www.makeuseof.com/tag/a-quick-guide-to-get-started-with-the-linux-command-line/">here's</a> one.</p>
<p>Once you have a shell, you'll see a prompt, something like:</p>
<pre><code>    student100:~$ _
</code></pre>
<p>From there you can type commands to the shell.</p>
<p>The shell is (mostly) just another program that  interprets
your commands and runs the relevant programs, so e.g. if
you want to know where your "home" directory is on the
disk you can type:</p>
<pre><code>    student100:~$ /bin/pwd
    /home/student100
</code></pre>
<p>And you see that the directory <code>/home/student100</code> is,
as you might expect, your home directory. (Your home
directory is also stored in an <a href="https://www.digitalocean.com/community/tutorials/how-to-read-and-set-environmental-and-shell-variables-on-a-linux-vps">environment variable</a>, so 
this also works:</p>
<pre><code>    student100:~$ echo $HOME
    /home/student100
</code></pre>
<p>You can now use the <code>man</code> command to get some
help, or search online for loads of explanations as to
how to use a shell.</p>
<p>You'll also need to be non-dumb of course, as there
are commands that can delete or break things. (Hopefully
not too badly in the lab!) The <code>rm</code> command in
particular is one to be careful of, especially if you
ever tell it to delete an entire directory tree via
the <code>-rf</code> <a href="https://blog.mafr.de/2007/08/05/cmdline-options-in-shell-scripts/">command line option</a>!
So: BE CAREFUL!</p>
<p>There are a variety of different shells available, with
minor variations in syntax when you start to use more
complicated commands and scripting. I use the <code>bash</code>
shell myself and am happy with that, you may choose
another one. There's a <code>chsh</code> command that you
can use to change the shell you're using, check out
it's man page if you want to switch.</p>
<p>You can also personalise the shell (e.g. to set the
kind of prompts I show here), usually via editing
a "hidden" file in your home directory. In the case
of the bash shell, that file is <code>$HOME/.bashrc</code>.
("Hidden" file names start with a dot and are 
not displayed by the <code>ls</code> command unless you
ask to see 'em via the <code>-a</code> command line option.
They useful so as to not clutter things up, but
are just normal files in the filesystem otherwise.)</p>
<p>As a last preliminary, you can change your password
via the <code>passwd</code> command. If you've been given
a crappy easily guessed password, then changing
that is probably a good plan. But if you forget
your new password, expect me, the TA and demonstrators
to be unhappy with you! </p>
<p>You should also expect
that someone else is likely to try guess your password,
especially if a system is accessible to the 
Internet via SSH and allows password logins. In
that case, the chances are that brute-force password attacks
will be made against the system every few minutes.
(As correctly stated <a href="https://serverfault.com/questions/801546/someone-is-trying-to-brute-force-ssh-access-to-my-server">here:</a>
"Unfortuntately, this is absolutely normal and something every SSH server experiences. Welcome to the internet.";-)</p>
<p>Most systems should have tooling to avoid that problem, but
not all do, and you as a user don't know when a
system is well protected or not - so ONLY EVER USE
STRONG PASSWORDS!</p>
<p>The next thing we want to do is clone the github repository
for the course and then run the <a href="../bm/README.html">broken malloc</a>
example.</p>
<h2>Clone <a href="https://github.com/sftcd/cs2014">this repo</a>...</h2>
<p>I usually keep repositories like this in a <code>code</code>
directory below my home directory so...</p>
<pre><code>    student100:~$ mkdir code    
    student100:~$ cd code
</code></pre>
<p>Another abbreviation for $HOME is the tilda character (<code>~</code>) which 
is why that may be part of the prompt depending on
your preferences. So, if you're logged in as student100, the following names for that
<code>code</code> directory are equivalent:</p>
<pre><code>    /home/student100/code/
    ~/code/
    $HOME/code/
</code></pre>
<p>Of course for <code>student666</code>, <code>$HOME/code</code>
and <code>~/code</code> will refer to <code>/home/student666/code/</code> instead.</p>
<p>Now you want to get a copy of this repository:</p>
<pre><code>    student100:~/code$ git clone https://github.com/sftcd/cs2014.git
    Cloning into 'cs2014'...
    remote: Counting objects: 139, done.
    remote: Compressing objects: 100% (89/89), done.
    remote: Total 139 (delta 73), reused 111 (delta 48), pack-reused 0
    Receiving objects: 100% (139/139), 714.98 KiB | 587.00 KiB/s, done.
    Resolving deltas: 100% (73/73), done.
</code></pre>
<p>The output you see will differ from the above as I'll have modified
the repo by then.</p>
<p>And now you can go build and run the first <code>`broken-malloc</code>
example:</p>
<pre><code>    student100:~/code$ cd cs2014/examples/bm
    student100:~/code/cs2014/examples/bm$ make
    gcc     broken-malloc.c broken-malloc.h   -o broken-malloc
    student100:~/code/cs2014/examples/bm$ ./broken-malloc 
    Malloc 1 succeeded!
    Malloc 2 failed!
    Malloc 3 succeeded!
    Malloc 4 succeeded!
    Malloc 5 failed!
    Malloc 6 succeeded!
    Malloc 7 succeeded!
    Malloc 8 succeeded!
    Malloc 9 succeeded!
    Malloc 10 succeeded!
    Tests: 10, fails: 2
    student100:~/code/cs2014/examples/bm$
</code></pre>
<p>Yay! Success!</p>
<p>From now on, for clarity, I'll just show prompts as <code>$</code> and
omit the rest of the verbiage. (That stuff is useful though if
you have a number of windows with a shell open, so's you don't
type a command into the wrong place.)</p>
<p>Once you've gotten this far, I'd suggest you play about with the
<code>broken-malloc</code> example, and see what you can change. Trying to
implement and test the <code>realloc()</code> function is a fine
plan.
If you manage to make it better (or interestingly different),
and you have a github.com account,
then feel free to submit a <a href="https://help.github.com/articles/about-pull-requests/">pull-request</a> (PR) and if it's good I'll
accept that and maybe use it another year. Put your name
somewhere in the PR I can see it, so's I know who's submitted
what. (I'll even take typo-fixes, as I'm pretty bad at getting
rid of all the typos in my text/code;-)</p>
<h2>Editing files... probably using <code>vi</code></h2>
<p>In order to play about with the example, you need a way to
edit files. My preferred tool for that is <code>vi</code> which is
a venerable editor that is still excellent today. 
There are loads of <a href="https://www.smashingmagazine.com/2010/05/vi-editor-linux-terminal-cheat-sheet-pdf/">vi cheatsheets</a>
available online and spending a bit of time getting 
familiar with <code>vi</code> is well worthwhile - you'll be
using it for many years to come, so getting speedy at
editing with it is really a MUST. You don't need to
do all that at first though, it's fine to learn as you
go and get faster later.</p>
<p>Anyway, if
you wanted to edit the <code>broken-malloc.h</code> file
then you simply say <code>vi broken-malloc.h</code> while in
the right directory and off you go. If you've not
checked out a cheatsheet, you'll likely get stuck
there and never figure out that to exit the editor
without saving changes you need to type <code>:q!</code>,
and to exit saving changes it's: <code>:wq</code></p>
<p>If you've not used <code>vi</code> before this is a really
good thing to ask about in the first lab.</p>
<p>There are plenty of other editors available on many
linux systems, from the most basic <code>ed</code> to 
<code>emacs</code> which I think is a bit of a monster. Many
people though just love and swear by <code>emacs</code>  (for
too much information about emacs, go <a href="https://www.gnu.org/software/emacs/">here</a>.)
In any case, 
try out various editors if you like and see which you find most comfortable.</p>
<p>BTW, <code>ed</code> is something I've not used in 
many years, and you'll only likely need to use it
if editing a file over a gigantically crappy network
that's dropping almost all packets or that has
multiple satellite hops on the path. But the
fact that tool is still there shows up a strength
of UNIX and GNU/Linux - pretty much no matter what
scenario you hit, there's a tool that works as well
as can be expected for that scenario.</p>